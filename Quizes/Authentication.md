# Authentication

## HTTPS, Cookie, Session, Token

---

1. **다음 중 HTTPS에 대한 설명으로 올바르지 않은 것은?**

- A 인증서를 기반으로 데이터 제공자의 신원을 보장받을수 있다.
- B 기존 HTTP 방식보다 더 안전한 통신 프로토콜이다.
- C 공개 키 암호화 (Public-key cryptography) 방식을 사용한다.
- D 최근 트렌드에서 멀어진 프로토콜이다.

---

정답: D

HTTPS는 최신 통신 프로토콜의 기반입니다. 기존의 HTTP를 사용한 통신은 제 3자가 중간에 요청을 가로채갈 경우 데이터를 쉽게 빼낼 수 있었지만, HTTPS를 사용한 통신은 암호화가 되어있기 때문에 제 3자가 중간에 요청을 가로 채도 쉽게 복호화 할 수 없습니다.

---

2. **비대칭 키 암호화에 대한 설명으로 올바른 것을 모두 고르세요.**

- A 암호화와 복호화에 서로 다른 키를 사용하는 방식이다.
- B public key는 누구에게나 공개해도 되는 키다.
- C public key로 암호화한 데이터는 그에 맞는 private key로만이 복호화가 가능하다.
- D private key로 암호화한 데이터는 public key로는 복호화가 불가능하다.

---

정답: A, B

private key 와 public key는 한쌍 이다. public key 소유자 (누구나 소유 가능)는 private key로 암호화된 서버에서 받은 데이터를 복호화가 가능하며, private key 소유자 (서버)는 public key로 암호화 한 데이터를 복호화가 가능하 다. public key는 누구나 가지고 있을 수 있음에도 이런 방식을 사용하는 이유는 공개키가 데이터 제공자의 신원을 보장해주기 때문이다.

암호화된 데이터가 공개키로 복호화된다는 것은, 공개키와 쌍을 이루는 개인키에 의하여 암호화 됬다는 것을 의미 한다. 즉 데이터 제공자의 신원 확인이 보장된다는 것이다.

---

3. **다음 중 해시함수에 대한 설명으로 올바른 것을 모두 고르세요.**

- A 해싱알고리즘은 해독이 절대 불가능하다.
- B SHA-256 알고리즘을 사용했을 경우 출력값의 길이는 언제나 동일하다.
- C 해시 알고리즘은 특정 입력값에 대해 항상 같은 해시값을 리턴한다.
- D 입력값이 다르면 해시된 출력값도 모두 다르다.

---

정답: B, C

A. 거의 불가능 하지만 아예 불가능하지는 않다. 현실적으로는 시간이 오래걸려 불가능 하지만, 수학적으로는 가능 하다. MD5는 일반적인 컴퓨터를 이용하여 2013년도에 20시간을 들여 90% 이상을 해독하는데 성공했다.

B. SHA-256 알고리즘을 사용했을 경우 출력값의 길이는 입력값의 길이와 관계없이 언제나 256비트(64글자)다.

C. 이 점을 이용해서 인증을 할 수 있는 것이다. 어떤 입력값인지는 모르지만 해시 함수를 이용해서 해시된 값이 일 치하다면 입력값이 같다는 것을 입증할 수 있다.

D. 극히 드물게 다른 입력값인데 해시된 값이 같은 경우가 발생할 수 있다. 입력은 길이제한이 없다면 무한정으로 만 들어 낼 수 있지만, 해시된 값은 항상 고정된 길이의 값으로 나타내므로 한계가 있기 때문에 입력값이 달라도 해시된 값이 같은 경우가 나타날 수 있다. 이러한 중복이 발생하는 것이 드물수록 좋은 해싱 함수라고 할 수 있다.

---

4. **해싱 함수를 만들 때 고려해야할 사항이 아닌 것은?**

- A 해시 값을 계산하는데 오래 걸리지 않아야 한다.
- B 충돌하는해시값이나올경우,리인덱싱을할수있어야한다.
- C 아주작은단위의변경이라도,완전히다른해시값을가져야한다.
- D 최대한 중복되는(충돌하는) 해시 값을 피하여 모든 값들이 각각 고유한 해시 값을 가지게 만들어야 한다.

---

정답: B

무수히 많은 입력값을 커버해야 한다면 충돌하는 해시값이 결국 발생할 수 밖에 없을 것이다. 이것을 방지하기 위해 선 리 인덱싱을 할 수 있는 해싱 함수를 만드는 것이 아닌 입력값의 크기를 조절하는 것이 더 우선이며, 최대한 충돌 하는 해시값이 발생하지 않는 해싱함수를 만드는 것을 고려해야 한다.

---

5. **다음 중 쿠키에 대한 설명으로 올바지르지 않은 것은?**

- A 삭제하지 않는한 영원히 보존된다. 로그인 유지 옵션등 장시간 유지해야하는 옵션의 구현에 유리하다.
- B 스크립트를 이용해서 누구나 쉽게 접근할 수 있다.
- C sameSite 옵션은 프로토콜 상관없이 none으로 지정할 수 있다.
- D 요청하는 서버의 도메인, 경로, sameSite등의 조건이 맞아 떨어질 경우 같이 전송된다.

---

정답: C

sameSite 옵션은 CSRF를 막기위한 옵션으로 크롬버전 80번 업데이트 이후 주력 브라우저가 대부분 적용한 옵션으 로 기본값은 sameSite=Lax 다. sameSite=Lax 인경우 CORS 요청은 안전한 GET 메서드 등만 서버에서 클라이언 트로 쿠키를 전송할 수 있다.

sameSite=none은 모든 요청에 대해 서버가 쿠키를 보내줄 수 있지만 Secure 옵션 및 HTTPS 프로토콜을 이용해야 한다.

---

6. **쿠키에서 사용할 수 있는 옵션들을 3가지 이상 적고, 각 옵션이 어떤 기능을 하는지 적으세요.**

정답:

- domain - 서버와 요청의 도메인이 일치하는 경우 쿠키 전송
- path - 서버의 요청의 세부경로가 일치하는 경우 쿠키 전송
- maxage/expires - 쿠키의 유효기간 설정
- httpOnly - 스크립트의 쿠키 접근 가능 여부 설정
- secure - HTTPS 에서만 쿠키 전송 여부 설정
- sameSite - CORS 요청의 경우, 옵션 및 메서드에 따라 쿠키 전송 여부 설정

---

7. **쿠키의 sameSite 옵션의 설명으로 올바른 것을 모두 고르세요.**

- A Lax: GET 요청만 쿠키 전송이 가능하다.
- B Strict: 쿠키 전송을 할 수 없다.
- C None: 모든(GET, POST, PUT 등등) 요청에 대해 쿠키 전송이 가능하다.

---

정답: 모두 다 올바른 설명입니다.

---

8. **다음 중 session에 대한 설명으로 올바르지 않은 것은?**

- A 서버에 접속 상태가 저장된다.
- B 여러개의 서버를 가지고 있을 때 유리하다.
- C 신뢰할 수 있는 유저인지 확인이 가능하다.
- D Cookie에 세션 아이디가 저장된다.

---

정답: B

세션은 보통 하나의 서버에서만 접속 상태를 저장한다. 여러개의 서버에서 같은 세션 데이터에 접근하려고 한다면 session clustering을 사용해야 하는 번거로움이 있다 (고로 불가능한것은 아니다).

---

9. **쿠키와 세션의 차이점에 대해 서술하세요.**

정답:

쿠키를 사용하면 사용자 정보가 클라이언트에 남고 보안상 문제가 발생할 수도 있다.
그러나 세션을 사용하면, 서버 메모리에 저장되어 쿠키와는 달리 사용자 정보가 노출되지 않는다.

---

10. **다음 중 CSRF에 대한 설명으로 올바른 것을 고르세요.**

- A 다른 오리진에서 유저가 보내는 요청을 조작하는 것.
- B 요청에 담긴 데이터에 해커가 직접 접근할 수 있는방법이다.
- C 요청이 갈 주소(API endpoint)와 메소드(GET, POST, PUT, 등)를 알고 있다면 공격이 가능하다.
- D 쿠키, 세션, 토큰, Oauth를 사용한 모든 인증 방식에 공격을 할 수 있다.

---

정답: A

cross site request forgery, 즉 유저가 보내는 요청을 다른 오리진에서 위조하는 것이다. 위조라는 이름 때문에 직 접 데이터를 수정하는 것 같지만, 사실 요청에 담길 데이터를 직접 바꾸는 것이 아닌 다른 임의의 endpoint에 query parameter만 변경하여 전송하는 등의 방법이다. 어떤 메소드로 요청을 하는지(GET, POST, PUT, 등), 어떠한 endpoint에 요청을 보낼때 필요한 parameter가 무엇인지만 안다면 요청을 위조하여 보낼 수 있다(가령 username 을 phillip에서 hacker로 변경하는것처럼). 쿠키 방식의 인증을 사용하는 곳에서 사용이 가능하며 sameSite 옵션을 사용하면 많은 csrf공격을 방지할 수 있다.

---

11. **CSRF 공격을 막을 수 있는 방법은 무엇이 있는지 서술하세요.**

정답:

CSRF 토큰을 사용하는 방법과, SameSite cookies를 사용하는 방법이 있다.

SameSite 옵션 사용, 특수 문자열을 유저의 브라우저/웹 앱에 제공하여 비교 (사실상 sameSite인지 확인하는 것과 동일한 개념이다)

---

12. **다음 중 세션에 대한 설명으로 옳은 것을 모두 고르면?**

- A 서버와 클라이언트의 연결이 활성화된 상태 자체를 의미한다.
- B 클라이언트의 브라우저에 세션 객체가 저장되어 관리된다.
- C 클라이언트에 개별적으로 발급되는 세션 id는 헤더의 'set-session' 속성에 담겨야 한다.
- D 세션이 활성화가 되면, 서버는 클라이언트를 구분하기 위해 각 클라이언트에 세션 id를 발급한다.
- E 쿠키와 완전히 별개의 개념으로, 쿠키의 단점을 보완하기 위해 등장한 기술이다.

---

정답: A, D

- A 서버와 클라이언트의 연결이 활성화된 상태 자체를 의미한다.
- D 세션이 활성화가 되면, 서버는 클라이언트를 구분하기 위해 각 클라이언트에 세션 id를 발급한다.

오답풀이:

- B 세션 정보가 클라이언트, 서버 둘 다 저장이 된다.
  세션 객체(인증정보)는 서버에 저장

- C set-session이 아니라 set-cookie
  set-cookie는 응답에 담긴다.
  응답에 한번 담기고 나면 req.header.cookie에 자동으로 담김

- E 별개가 아니라 쿠키의 한계를 보완하기 위한 것

---

13. **유저가 어떤 팝업 창에 대해 '7일간 다시 보지 않기'를 선택할 경우, 해당 설정은 무엇을 통해 저장하는 것이 가장 바람직할까요?**

정답: 쿠키

---

14. **express-session을 통해 세션 객체에 'username'이라는 데이터를 저장하려 합니다. 다음 중 올바른 방법은 무엇일까요?**

- A req.session.id.username = 'myusername'
- B req.session.username = 'myusername'
- C req.session.cookie.username = 'myusername'
- D req.cookie.username = 'myusername'

---

정답: B req.session.username = 'myusername'

---

15. **암호화에서 솔트(salt)란 무엇일까요?**

정답: 암호화해야 하는 값에 어떤 별도의 값을 추가하여 결과를 변형하는 것

- MYSALTmypassword -> sha256 HASH -> de234ae
- 서버가 데이터 베이스에 저장한 암호는 de234ae
- 사용자가 로그인 시도시 서버가 하는 일
- MYSALT + 사용자 입력 -> sha256 HASH -> 결과와 DB에 쌓인 것 비교

---

16. **다음 HTTP 통신의 특성 가운데, cookie 및 session을 사용하는 이유와 가장 밀접한 연관이 있는 것은 무엇일까요?**

- A connectionless
- B stateless
- C media independent
- D All of the above

---

정답: B, stateless

---

17. **다음 중 토큰에 대한 설명으로 옳은 것은?**

- A 서버에서만 토큰을 저장하고 관리한다.
- B 인증을 위해 사용되는 암호화된 문자열이다.
- C 서버는 유저의 요청에 담긴 토큰이 유효한지, 유저가 현재 브라우저에 접속 중인지 여부 등을 확인한다.
- D 세션 및 쿠키와 마찬가지로, 유저가 보내는 모든 요청에 포함된다.

---

정답: B, D

- B 인증을 위해 사용되는 암호화된 문자열이다.
- D 세션 및 쿠키와 마찬가지로, 유저가 보내는 모든 요청에 포함된다.

---

18. **node.js crypto 모듈의 createHmac 메서드를 사용하여 'topSecret!'이라는 문자열을 암호화하고자 합니다. 다음 코드에서 잘못된 부분은 어디이고, 틀린 이유는 무엇일까요?**

```
const crypto = require('crypto');
const yourSecretKey = 'thisIsMySecretKey'
const hash = crypto.createHmac('topSecret!', yourSecretKey)
		.update('topSecret!')
        .digest('base64');
```

- A .createHmac('topSecret!', yourSecretKey)
  createHmac()
  - 메서드는 인자로서 알고리즘만을 받는다.
- B .createHmac('topSecret!', yourSecretKey)
  - crypto.createHmac()은 알고리즘과 키를 인자로 받아야 한다.
- C .update('topSecret!')
  - createHmac()에서 데이터와 키를 인자로 넣은 경우, update메서드는 생략해야 한다.
- D .digest('base64')

---

정답: A

인코딩이 아니라 알고리즘을 인자로 넣어 주어야 한다.

- .createHmac('topSecret!', yourSecretKey)
- crypto.createHmac()은 알고리즘과 키를 인자로 받아야 한다.
- crypto.createHmac(SHA256, yourSecretKey)
